vec4 shade(intersectResult result, Ray ray){

		//ray direciton
		vec3 n = normalize(ray.direction);
		vec3 viewDir = normalize(-ray.direction);

		vec3 intersect = ray.origin + (result.dist)*n;
		vec3 surfaceNormal = normalize(intersect - result.pos);
		vec3 lightDir = normalize(light.pos - surfaceNormal);


		vec3 intPos = surfaceNormal;
		float x = 0.5 + atan(intPos.z, -intPos.x) / (2*PI);
		float y = 0.5 - asin(intPos.y) / PI;

		vec3 albedo = vec3(texture(u_albedo[result.texId], vec2(x, y)));
		float metalic = vec3(texture(u_metalic[result.texId], vec2(x, y))).r;
		float roughness =  vec3(texture(u_roughness[result.texId], vec2(x, y))).r;


		vec3 h = normalize(viewDir + lightDir);

		float dist = length(lightDir - surfaceNormal);
		float attenuation = 1.0/pow(dist,2);
		vec3 radiance = vec3(light.color) * attenuation;

		vec3 f0 = albedo;
		f0 = mix(f0, albedo, metalic);

		float ndf = DistributionGGX(surfaceNormal, h, roughness);
		float g = GeometrySmith(surfaceNormal, viewDir, lightDir, roughness);
		vec3 f = fresnelSchlick(max(dot(h,viewDir),0.0), f0);

		vec3 numerator = ndf * g * f;
		float denominator = 4.0 * max(dot(surfaceNormal, viewDir),0.0) * max(dot(surfaceNormal, lightDir),0.0);
		vec3 specular = numerator / max(denominator, 0.0001);

		vec3 ks = f;
		vec3 kd = vec3(1.0)- ks;
		kd *= 1.0-metalic;

		float ndotl = max(dot(surfaceNormal, lightDir), 0.0);
		vec3 Lo = vec3(0);

		Lo += (kd * vec3(albedo) / PI + specular) * radiance * ndotl;

		vec3 ambient = vec3(0.03) * albedo;

		vec3 color = ambient +  Lo;

		vec4 outColor = vec4(color,1.0f);

		return outColor;
}
