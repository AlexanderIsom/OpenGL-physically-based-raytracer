#version 430 core
out vec4 fColor;

struct Ray{
	vec3 origin;
	vec3 direction;
};

struct Sphere{
	vec3 pos;
	vec4 Color;
	float radius;
};

Sphere objects[2];

struct LightSrc{
	vec3 pos;
	vec3 direction;
	vec4 color;
	float strength;
};

float facing(vec3 a, vec3 b){
	if(dot(a,b) > 0.0f)
	{
		return 1.0f;
	}
	return 0.0f;
};

in vec3 vertexPos;
float closest;

uniform mat4 viewMatrix;
uniform mat4 projectionMatrix;

void main(){
	LightSrc light;

	bool hit;

	hit = false;

	closest = -1;

	vec4 backGroundColor = vec4(0.0, 0.2 ,0.0,1.0);

	Ray ray;

	vec4 startPoint;
	vec4 endPoint;

	startPoint = vec4(vertexPos.x,vertexPos.y,-1,1);
	startPoint = inverse(projectionMatrix) * startPoint;
	startPoint = startPoint / startPoint.w;
	startPoint = inverse(viewMatrix) * startPoint;
	
	endPoint = vec4(vertexPos.x,vertexPos.y,1,1);
	endPoint = inverse(projectionMatrix) * endPoint;
	endPoint = endPoint / endPoint.w;
	endPoint = inverse(viewMatrix) * endPoint;

	ray.origin = vec3(startPoint);
	//ray.direction = vec3(0.0,0.0,-1.0);
	ray.direction = vec3(normalize(endPoint - startPoint));


	//set up scene
	objects[0].pos = vec3(-0.25,0.0, -1.0);
	objects[0].radius = 0.5f;
	objects[0].Color = vec4(0.0,1.0,0.0,1.0);

	objects[1].pos = vec3(0.25,0.0, -2.0);
	objects[1].radius = 0.5f;
	objects[1].Color = vec4(0.0,1.0,0.0,.0);	

	light.pos = vec3(-10.0,1.0,10.0);
	light.color = vec4(1.0);


	//check to see if the origin of the ray is inside of the sphere

	for (int i = 0; i < objects.length(); i++){

		vec3 pa = objects[i].pos - ray.origin;
		float dist = length(pa);
		vec3 n = normalize(ray.direction);
		float a = dot(pa,n);

		//its inside the sphere, draw blue sphere
		if(dist <= objects[i].radius){
		   fColor = vec4(0.0, 0.0,1.0,1.0);
		   //goto next object
		   return;
		}	

		vec3 closePoint = ray.origin + a*n;

		//dist = dot(closePoint,n);

		//object is behind camera, dont draw at all
		if(dot(pa,n) < 0){	
			fColor = vec4(1.0, 0.0,1.0,1.0);
			//go to next object
			return;
		}

		vec3 dVec = pa - (a*n);
		dist = length(dVec);

		if(dist <= objects[i].radius){
			
			hit = true;

			if(closest < 0){
			closest = dist;
			}

			if(dist<=closest){

				float x;
				x = sqrt(pow(objects[i].radius,2)-pow(dist,2));
				float hitDist = a-x;

				//intersection point
				vec3 intersect = ray.origin + (hitDist)*n;


				//SHADING
				//get surface normal

				vec3 surfaceNormal = normalize(intersect - objects[i].pos);
				light.direction = normalize(light.pos - intersect);
				vec3 viewDir = normalize(vertexPos - intersect);
				vec3 midDir = normalize(light.direction + viewDir);


				//phong shading model
				float shinyness = 10.f;
				float ambientStr = 0.1f;

				vec4 ambient = vec4(ambientStr);
				vec4 diffuse = vec4(max(dot(surfaceNormal, light.direction),0.0f));

				vec4 specular = vec4(facing(surfaceNormal, light.direction) * pow(max(dot(surfaceNormal, midDir), 0.0f), shinyness));

				vec4 outColor = ambient + diffuse + specular;

				outColor = outColor * light.color * objects[i].Color * 1.0f;
		
				fColor = outColor / 3.0f;
			}
		}
	}
	if(hit == false){
		fColor = backGroundColor;
	}
	return;
}

//TODO
//Multiple spheres in a list, one partially behind the other, try get shadows