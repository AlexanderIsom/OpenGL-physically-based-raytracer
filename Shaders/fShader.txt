#version 430 core
out vec4 fColor;

in vec3 vertexPos;

uniform mat4 viewMatrix;
uniform mat4 projectionMatrix;

int id;

struct Ray{
	vec3 origin;
	vec3 direction;
	vec3 n;
};

struct hitObject{
	vec3 pos;
	vec4 Color;
	float radius;
	float shinyness;
	float dist;
	bool hit;
};

vec4 backGroundColor = vec4(0.0, 0.0 ,0.0,1.0);

struct Sphere
{
	vec3 pos;
	vec4 Color;
	float radius;
	float shinyness;
	
};

Sphere objects[2];

struct LightSrc{
	vec3 pos;
	vec3 direction;
	vec4 color;
	float strength;
};

LightSrc light;

float facing(vec3 a, vec3 b){
	if(dot(a,b) > 0.0f)
	{
		return 1.0f;
	}
	return 0.0f;
};


hitObject rayIntersect(Sphere sph, Ray ray)
{
	hitObject rtn;
	rtn.hit = false;
	rtn.dist = -1.0f;
	rtn.Color = backGroundColor;

	vec3 n = ray.n;
	vec3 pa = sph.pos - ray.origin;
	float dist = length(pa);
	float a = dot(pa,n);

	//its inside the sphere, draw blue sphere
	if(dist <= sph.radius)
	{
		rtn.Color = vec4(0.0, 0.0,1.0,1.0);
		   
		//goto next object
		rtn.hit = false;
		return rtn;
	}	

	//object is behind camera, dont draw at all
	if(dot(pa,n) < 0)
	{	
		rtn.Color = vec4(1.0, 0.0,1.0,1.0);
		//go to next object
		rtn.hit = false;
		return rtn;
	}

	vec3 dVec = pa - (a*n);
	dist = length(dVec);

	if(dist <= sph.radius)
	{
		float x = sqrt(pow(sph.radius,2)-pow(dist,2));
		float hitDist = a-x;
		rtn.pos = sph.pos;
		rtn.radius = sph.radius;
		rtn.shinyness = sph.shinyness;
		rtn.Color = sph.Color;
		rtn.dist = hitDist;
		rtn.hit = true;
	}

return rtn;
}

void addObject(vec3 P, float R, vec4 C, float shinyness){
	
	objects[id].pos = P;
	objects[id].radius = R;
	objects[id].Color = C;
	objects[id].shinyness = shinyness;

	id++;
}


vec4 genRay(vec4 startPoint, vec4 endPoint){

	Ray ray;

	vec4 rtnColor;

	hitObject rtn;
	hitObject hitObj;
	hitObj.hit = false;
	hitObj.dist = -1.0f;

	startPoint = projectionMatrix * startPoint;
	startPoint = viewMatrix * startPoint;
	startPoint = startPoint / startPoint.w;
	
	endPoint = projectionMatrix * endPoint;
	endPoint = viewMatrix * endPoint;
	endPoint = endPoint / endPoint.w;

	ray.origin = vec3(startPoint);
	ray.direction = vec3(normalize(endPoint - startPoint));

	ray.n = normalize(ray.direction);
	
	for (int i = 0; i < objects.length(); i++)
	{		
		rtn = rayIntersect(objects[i], ray);

		if(rtn.hit == true){
			rtnColor = rtn.Color;
			if(rtn.dist < hitObj.dist || hitObj.dist < 0 && rtn.dist != hitObj.dist)
			{		
				hitObj.pos = rtn.pos;
				hitObj.radius = rtn.radius;
				hitObj.Color = rtn.Color;
				hitObj.dist = rtn.dist;
				hitObj.shinyness = rtn.shinyness;	
				hitObj.hit = true;
			}
		}
	}

	if(hitObj.hit == true){	
		//if shiny

		//intersection point
		vec3 intersect = ray.origin + (hitObj.dist)*ray.n;

		//get surface normal
		vec3 surfaceNormal = normalize(intersect - hitObj.pos);

		if(hitObj.shinyness > 100.0f)
		{
			//vec3 newRayDir = (-ray.direction)+2*(dot(ray.direction,surfaceNormal))*surfaceNormal;
			//rtnColor = genRay(intersect, newRayDir, hitObj);

		}
		else
		{		

			//SHADING
			
			light.direction = normalize(light.pos - intersect);
			vec3 viewDir = normalize(vertexPos - intersect);
			vec3 midDir = normalize(light.direction + viewDir);


			//phong shading model // needs to be updated with pbr
			
			float ambientStr = 0.1f;

			vec4 ambient = vec4(ambientStr);
			vec4 diffuse = vec4(max(dot(surfaceNormal, light.direction),0.0f));

			vec4 specular = vec4(facing(surfaceNormal, light.direction) * pow(max(dot(surfaceNormal, midDir), 0.0f), hitObj.shinyness));

			vec4 outColor = ambient + diffuse + specular; // reflectivity

			outColor = outColor * light.color * hitObj.Color * 1.0f;
		
			rtnColor = outColor / 3.0f;
		}
	}
	if(hitObj.hit == false){
		rtnColor = backGroundColor;
	}

	return rtnColor;
};



//overloaded funciton to gen ray with passing in the object it was spawned from. 

//dont intersect test spawned object

void main(){

	//generate ray from screen coords

	//set up scene
	addObject(vec3(0.0,0.0, -1.0),0.1f,vec4(0.0,1.0,0.0,1.0),50.0f);
	addObject(vec3(0.3,0.0, -2.0),0.1f,vec4(0.0,1.0,0.0,1.0),10.0f);

	light.pos = vec3(-10.0,1.0,10.0);
	light.color = vec4(1.0);

	fColor = genRay(vec4(vertexPos.x,vertexPos.y,-1,1), vec4(vertexPos.x,vertexPos.y,1,1));
	
	return;
}