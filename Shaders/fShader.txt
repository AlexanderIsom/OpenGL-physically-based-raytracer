#version 430 core
out vec4 fColor;

struct Ray{
	vec3 origin;
	vec3 direction;
};

struct Sphere{
	vec3 pos;
	vec4 Color;
	float radius;
};

struct LightSrc{
	vec3 pos;
	vec3 direction;
	vec4 color;
	float strength;
};

float facing(vec3 a, vec3 b){
	if(dot(a,b) > 0.0f)
	{
		return 1.0f;
	}
	return 0.0f;
};

in vec3 vertexPos;

void main(){
	bool hit = false;
	Sphere sphere;
	LightSrc light;

	vec4 backGroundColor = vec4(0.0, 0.0,0.0,1.0);

	Ray ray;


	sphere.pos = vec3(0.0,0.0, -1.0);
	sphere.radius = 0.5f;
	sphere.Color = vec4(0.0,1.0,0.0,1.0);

	ray.origin = vertexPos;
	ray.direction = vec3(0.0,0.0,-1.0);

	light.pos = vec3(-10.0,1.0,10.0);
	light.color = vec4(1.0);


	//check to see if the origin of the ray is inside of the sphere

	vec3 pa = sphere.pos - ray.origin;
	float dist = length(pa);
	vec3 n = normalize(ray.direction);
	float a = dot(pa,n);

	//its inside the sphere, draw blue sphere
	if(dist <= sphere.radius){
	   fColor = vec4(0.0, 0.0,1.0,1.0);
	   hit = false;
	   //goto next object
	   return;
	}	

	vec3 closePoint = ray.origin + a*n;

	//dist = dot(closePoint,n);

	//object is behind camera, dont draw at all
	if(dot(pa,n) < 0){	
		fColor = vec4(1.0, 0.0,1.0,1.0);
		//go to next object
		return;
	}

	vec3 dVec = pa - (a*n);
	dist = length(dVec);

	if(dist <= sphere.radius){
		float x;
		x = sqrt(pow(sphere.radius,2)-pow(dist,2));
		float hitDist = a-x;

		//intersection point
		vec3 intersect = ray.origin + (hitDist)*n;


		//SHADING
		//get surface normal

		vec3 surfaceNormal = normalize(intersect - sphere.pos);
		light.direction = normalize(light.pos - intersect);
		vec3 viewDir = normalize(vertexPos - intersect);
		vec3 midDir = normalize(light.direction + viewDir);


		//phong shading model
		float shinyness = 10.f;
		float ambientStr = 0.1f;

		vec4 ambient = vec4(ambientStr);
		vec4 diffuse = vec4(max(dot(surfaceNormal, light.direction),0.0f));

		vec4 specular = vec4(facing(surfaceNormal, light.direction) * pow(max(dot(surfaceNormal, midDir), 0.0f), shinyness));

		vec4 outColor = ambient + diffuse + specular;

		outColor = outColor * light.color * sphere.Color * 1.0f;

		
		fColor = outColor / 3.0f;
	}else{
		fColor = backGroundColor;
	}

	return;
}

//TODO
//Multiple spheres in a list, one partially behind the other, try get shadows